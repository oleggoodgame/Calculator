package com.example.calculator

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
// Переваги LiveData

//Реактивність та автоматичне оновлення UI:
//
//LiveData автоматично оновлює інтерфейс користувача, коли дані змінюються. Тобто вам не потрібно самостійно оновлювати UI після зміни даних, оскільки підписники (активності чи фрагменти) автоматично отримують зміни й оновлюються.
//Якщо використовувати просто списки, вам потрібно вручну відслідковувати зміни та оновлювати UI.
//Життєвий цикл (Lifecycle-aware):
//
//LiveData є "розумною" щодо життєвого циклу. Вона знає, коли Activity або Fragment є активними (в onStart чи onResume), і починає передавати оновлення тільки тоді, коли UI готовий до цього. Це допомагає уникнути проблем з оновленням інтерфейсу, коли активність ще не готова або вже знищена.
//Звичайний список не враховує життєвий цикл і може призвести до витоків пам'яті або спроб оновити знищений інтерфейс.
//Збереження даних при повороті екрану:
//
//Дані у LiveData, що знаходиться у ViewModel, зберігаються навіть після повороту екрану чи інших змін конфігурації. Це означає, що вам не потрібно повторно завантажувати дані або відновлювати стан вручну.
//Звичайний список знищується під час зміни конфігурації, тому ви втрачаєте дані.
//Менший ризик витоків пам'яті:
//
//LiveData управляє підписниками так, що немає ризику витоків пам'яті, оскільки вона від'єднує підписників, коли активність або фрагмент знищуються.
//У разі використання звичайних списків або інших об'єктів, потрібно самому керувати зв'язками між об'єктами, що може призвести до витоків пам'яті.
//Можливість легкої інтеграції з Room та іншими джерелами даних:
//
//Багато бібліотек у Android підтримують LiveData для реактивного оновлення даних. Наприклад, Room повертає об'єкти LiveData, тому інтеграція з базою даних є більш ефективною.
//Звичайний список не має таких можливостей і не може автоматично реагувати на зміни бази даних.
class RecyclerViewModel : ViewModel() {
    private val _text = MutableLiveData<String>()
    val text: LiveData<String> get() = _text

    private val _items = MutableLiveData<MutableList<String>>(mutableListOf())
    val items: LiveData<MutableList<String>> get() = _items

    fun setText(newText: String) {
        _text.value = newText
    }

    fun addItem(item: String) {
        _items.value?.let {
            it.add(item)
            _items.value = it // Оновлення LiveData
        }
    }

    fun removeItem(item: String) {
        _items.value?.let {
            it.remove(item)
            _items.value = it // Оновлення LiveData
        }
    }

    fun clearItems() {
        _items.value?.clear()
        _items.value = _items.value // Оновлення LiveData
    }
}

